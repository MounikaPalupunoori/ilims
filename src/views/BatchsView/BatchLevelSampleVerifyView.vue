<template>
  <div class="page-ht-90">
    <div style="background-color: #d9d9d9">
      <div class="container-fluid p-3">
        <div class="row row-cols-2 row-cols-sm-3 row-cols-md-3 justify-content-between">
          <div class="d-flex align-items-center">
            <span class="batchNo">Batch No.&nbsp;</span>
            <v-text-field density="compact" variant="outlined" readOnly
            :value="batchList && batchList.batch && batchList.batch[0] && batchList.batch[0].batchNumber"
              hide-details></v-text-field>
          </div>
        </div>
      </div>
    </div>
    <div style="background-color: white">
      <div class="p-4">
        <FormKit type="form" :incomplete-message="false" :actions="false" id="update-form-data" @submit="updateBatch">
          <v-row justify="space-around">
            <v-col cols="12" md="5" sm="12" xs="12">
              <div class="d-flex align-items-center">
                <span md="1" class="batchNo label-clr">Generated By&nbsp;&nbsp;</span>
                <div md="3" style="width: 100%">
                  <v-text-field density="compact" disabled variant="outlined"
                    :value="getBatchAttributeByName(batchList, 'generated_by')" hide-details></v-text-field>
                </div>
              </div>
            </v-col>

            <v-col cols="12" md="5" sm="12" xs="12">
              <div class="d-flex align-items-center">
                <span md="1" class="batchNo label-clr">Accepted By&nbsp;&nbsp;&nbsp;</span>
                <div md="3" style="width: 100%">
                  <FormKit style="
                        width: 100%;
                        background: white !important;
                        border: 1px solid #a9a9a9;
                        font-size: 16px !important;
                      " type="select" name="acceptedBy" v-model="UserEmail" validation="required"
                    placeholder="Accepted By" :options="studyTeam" />
                </div>
              </div>
            </v-col>
          </v-row>
          <v-row justify="space-around">
            <v-col cols="12" md="5" sm="12" xs="12">
              <div class="d-flex align-items-center">
                <span class="batchNo label-clr">Generated On&nbsp;&nbsp;</span>
                <div style="width: 100%">
                  <v-text-field density="compact" disabled variant="outlined"
                    :value="getBatchAttributeByName(batchList, 'generated_on')" hide-details></v-text-field>
                </div>
              </div>
            </v-col>
            <v-col cols="12" md="5" sm="12" xs="12">
              <div class="d-flex align-items-center">
                <span class="batchNo label-clr">Accepted On&nbsp;&nbsp;&nbsp;</span>
                <v-text-field density="compact" disabled variant="outlined" readOnly v-model="acceptedOn"
                  hide-details></v-text-field>
              </div>
            </v-col>
          </v-row>
        </FormKit>
      </div>
    </div>
    <v-table>
      <thead>
        <tr class="tr-bg">
          <th>
            <div class="d-flex align-items-center justify-content-center" style="font-weight: 600">
              <!-- <input type="checkbox" v-model="isCheckAll" @change="selectAllCheckboxes" /> -->
              <div class="pl-2 th-txt">Sample Barcode</div>
            </div>
          </th>
          <th v-for="(header, index) in headers" :key="index" scope="col" class="th-txt">
            {{ header }} <span v-if="header === 'Sample Verification'">
              <v-switch style="display: flex; justify-content: center" color="blue" name="verification"
                validation="required" v-model="toggleAll" @change="toggleAllSamples"></v-switch></span>
          </th>
        </tr>
      </thead>
      <tbody>
        <tr v-for="(item, index) in displayBatchList" class="tr-txt" :key="index">
          <td>
            <div class="d-flex align-items-center">
              <div class="pr-2">
                <!-- <input type="checkbox" v-model="item.isSelected" @change="onCheckboxChange(item)" /> -->
              </div>
              <div>{{ item.sampleBarcode ? item.sampleBarcode : '-' }}</div>
            </div>
          </td>
          <td v-if="props.batchType == 'LIB_PREP_DAY1' || props.batchType == 'LIB_PREP_DAY2'">{{ item.library_id ? item.library_id : "-" }}</td>
          <td v-if="props.batchType == 'LIB_PREP_DAY2'">{{ item.pool_id ? item.pool_id : "-" }}</td>
          <td>{{ item.suid ? item.suid : "-" }}</td>
          <td>{{ item.sample_type ? item.sample_type : "-" }}</td>
          <td>{{ item.collection_date ? Dateformat(item.collection_date) : '-'}}</td>
          <td>{{ item.received_date ? Dateformat(item.received_date): "-" }}</td>
          <td>
            <v-switch style="display: flex; justify-content: center" color="blue" name="verification"
              validation="required" v-model="item.switchState" @click="handleChange(item)"></v-switch>
          </td>
          <td>{{ item.facility ? item.facility : "-" }}</td>
          <td>{{ item.physician_name ? item.physician_name : "-" }}</td>
          <td>{{ item.status ? item.status : "-" }}</td>
        </tr>
      </tbody>
    </v-table>
    <div class="d-flex justify-content-center align-items-center br-bt buttons-fixed">
      <button type="button" class="btn border-btn m-2" @click="handleClose">
        close
      </button>
      <button type="submit" form="update-form-data" class="btn filled-btn">Save</button>
    </div>
    <EsignatureModal v-if="viewStore.eSignatureModal" :handleSubmit="handleSubmit" :text="EsignatureText()" />
    <v-snackbar :timeout="2000" location="top" v-model="showAlert" color="#dc3545">
      {{ alertMessage }}
      <template v-slot:actions>
        <v-icon @click="showAlert = false" icon="mdi mdi-close-circle-outline" />
      </template>
    </v-snackbar>
  </div>
</template>
  
<script setup>
import { defineProps, ref, watch, computed, reactive, onMounted } from 'vue';
import { useRouter } from 'vue-router';
import { SampleController } from '../../Controllers/sampleController';
import { useStudyStore } from '../../stores/studyStore';
import EsignatureModal from '../../components/EsignatureModal.vue';
import { useViewStore } from '../../stores/viewStore';
import { useFilterStore } from '../../stores/filterStore';
import { getAttributeValue, formatDate } from '../../Utils/helperFunctions';
import moment from 'moment';
import { Dateformat } from '../../Constants/formatDate'
const router = useRouter();
const studyStore = useStudyStore();
const filterStore = useFilterStore();
const viewStore = useViewStore();
const acceptedBy = ref("");
const props = defineProps({
  batchNo: String,
  sampleAttribute: String,
  batchType: String,
  navigate: String,
})
const studyTeam = ref([])
const batchId = ref(localStorage.getItem('batchId'))
const UserEmail = localStorage.getItem('userName')
const acceptedOn = ref(formatDate((new Date().getTime())));
const toggleAll = ref(false);
const batchListById = ref([]);
const showAlert = ref(false);
const alertMessage = ref("");
const batchList = ref([]);
let headers = [
  'PUID',
  'Sample Type',
  'Collection Date',
  'Received Date',
  'Sample Verification',
  'Hospital/Clinic',
  'Physician Name',
  'Sample Status'
]

const EsignatureText = () => {
  switch (props.batchType) {
    case 'DNA_ISOLATION':
      return 'I am verifying DNA isolation samples.';
    case 'LIB_PREP_DAY1':
      return 'I am verifying LIB_PREP_DAY1 samples.';
    case 'LIB_PREP_DAY2':
      return 'I am verifying LIB_PREP_DAY2 samples.';
    default:
      return '';
  }
}

onMounted(() => {
  filterStore.setParams('');
})

const fetchStudyTeam = async () => {
  const inputModel = {
    studyTeamModel: {
      studyId: studyStore.selectedStudy,
      accountStatus: [0, 1]
    }
  }
  const results = await SampleController.getStudyTeams(inputModel)
  if (results?.data?.length > 0) {
    studyTeam.value = results.data?.map((value) => {
      const isEmailMatch = value.userName === localStorage.getItem('userName')
      return {
        label: `${value.name} ${value.lname} (${value.email})`,
        value: value.email,
        attrs: { disabled: !isEmailMatch }
      }
    })
  }
}
const fetchBatchListById = async () => {
  const inputModel = {
    batchId: Number(batchId.value),
    studyId: studyStore.selectedStudy.toString(),
    sort:"asc.display_order",
  }
  const response = await SampleController.batchListById(inputModel);
  fetchStudyTeam()
  if (response?.data?.length > 0) {
    batchList.value = response.data[0];
    const batchData = response.data[0];
    for (let i = 0; i < batchData.batchEntities.length; i++) {
        const currentCaseSample = batchData.batchEntities[i];
        for (let j = 0; j < batchData.batchSampleDetails.length; j++) {
          const currentDataItem = batchData.batchSampleDetails[j];
          const batchEntityId = currentCaseSample.batchEntityId;
          const batchEntityAttr = batchData.batchEntityAttributes.reduce((acc, obj) => {
            if (obj.batchEntityId == batchEntityId) {
              acc[obj.attributeName] = obj.attributeValue
            }
            return acc;
          }, {})
          if (currentDataItem.caseSampleId === currentCaseSample.entityId) {
            batchListById.value.push({ ...currentDataItem, ...currentCaseSample, ...batchEntityAttr });
          }
        }
      }
  }
}
const displayBatchList = computed(() => {
  const data = batchListById.value
  if (data) {
    return data?.map((item) => {
      return reactive({
        ...item,
        switchState:getAttributeData(item.batchEntityId, props.sampleAttribute),
      });
    });
  }
  return data;
});
const getAttributeData = (batchEntityId, attributeName) => {
  const attribute = batchList?.value?.batchEntityAttributes?.find(
    (attrib) =>
      attrib.batchEntityId === batchEntityId && attrib.attributeName === attributeName
  );
  if (attribute) {
    let attributeValue = attribute.attributeValue;
    if (attributeName === props.sampleAttribute) {
      if (attributeValue === 'yes') {
        attributeValue = true;
      } else {
        attributeValue = false;
      }
      return attributeValue;
    } else {
      return attributeValue;
    }
  } else {
    return "";
  }
};



const toggleAllSamples = () => {
  displayBatchList.value.forEach((item) => (item.switchState = toggleAll.value));
}
const handleChange = (item) => {
  item.switchState = !item.switchState;
  const allSwitchStatesTrue = displayBatchList.value.every((item) => item.switchState);
  if (allSwitchStatesTrue) {
    toggleAll.value = true
  }
  else {
    toggleAll.value = false
  }
};

const getBatchAttributeByName = (data, attributeName) => {
    const attribute = data?.batchAttributes?.find((attr) => attr.attributeName === attributeName);
    if (attribute?.attributeValue != null) {
      if (attributeName === "generated_on") {
        const formattedDate = moment(attribute.attributeValue).format('MM-DD-YYYY hh:mm A');
        return formattedDate;
      } else {
        return attribute.attributeValue;
      }
    }
};

const updateBatch = (fields) => {
  acceptedBy.value = fields.acceptedBy
  viewStore.getEsignatureModal(true)
}
const handleClose=()=>{
  router.push(props.navigate)
}
watch(
  () => studyStore.selectedStudy,
  () => {
    if (props.batchType == 'LIB_PREP_DAY2') {
      headers.unshift('Pool Number');
    }
    if (props.batchType == 'LIB_PREP_DAY1' || props.batchType == 'LIB_PREP_DAY2') {
      headers.unshift('Library Id');
    }
    batchListById.value = []
    fetchBatchListById()
  },
  { immediate: true }
)

const handleSubmit = async () => {
  var batchEntity = []
  var batchEntityAttributeVal = []

  if (displayBatchList.value.length > 0) {
    displayBatchList.value.forEach((id) => {
      var batchEntityAttribute = {
        batchEntityId: id.batchEntityId,
        attributeName: getAttributeValue(
          studyStore.entityStudyAttributeModel,
          props.sampleAttribute
        ),
        attributeValue: id.switchState ? 'yes' : 'no'
      }
      var batchEntityObj = {
        batchId: Number(batchId.value),
        entityId: id.caseSampleId,
        entityName: "CASE_SAMPLE",
        batchEntityId: id.batchEntityId,
        batchEntityStatus: id.batchEntityStatus
      }
      batchEntity.push(batchEntityObj)
      batchEntityAttributeVal.push(batchEntityAttribute)

    });
  }
  const inputModel = {
    batchModel: {
      batch: {
        batchId: Number(batchId.value),
        batchName: batchList.value  && batchList.value.batch && batchList.value.batch[0].batchName,
        batchType: props.batchType,
        batchNumber:  batchList.value  && batchList.value.batch && batchList.value.batch[0].batchNumber,
        batchStatus: displayBatchList.value.some((item) => !item.switchState)
          ? 'PENDING'
          : 'ACCEPTED',
        batchAttributes: [
          {
            attributeName: 'accepted_by',
            attributeValue: acceptedBy.value
          },
          {
            attributeName: "accepted_on",
            attributeValue: new Date()
          }
        ],
        batchEntity: batchEntity,
        batchEntityAttributes: batchEntityAttributeVal
      }
    },
    eSignatureModel: {
      username: viewStore.eSignatureForm.username,
      password: viewStore.eSignatureForm.password,
      changeReasonDetail: viewStore.eSignatureForm.changeReasonDetail
    }
  };
  await SampleController.updateBatch(inputModel, router, props.navigate,props.batchType)
}

</script>
  
<style scoped>
.batchNo {
  color: #007bff;
  font-weight: 500;
  font-size: 18px;
  white-space: nowrap;
}

.tr-bg {
  background: #f4f3f3;
}

.th-txt {
  color: black !important;
}

.label-clr {
  color: #000000;
  font-size: 16px !important;
}

.nowrap {
  white-space: nowrap;
}
</style>
  